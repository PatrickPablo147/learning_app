class Lesson {
  List<List> lesson1 = [
    ["lib/assets/lesson1/1.png",
    "lib/assets/lesson1/2.png",
    "lib/assets/lesson1/3.png",
    "lib/assets/lesson1/4.png",
    "lib/assets/lesson1/5.png",
    "lib/assets/lesson1/6.png",
    "lib/assets/lesson1/7.png",
    "lib/assets/lesson1/8.png",
    "lib/assets/lesson1/9.png",
    ],
    [
      "lib/assets/lesson2/1.png",
      "lib/assets/lesson2/2.png",
      "lib/assets/lesson2/3.png",
      "lib/assets/lesson2/4.png",
      "lib/assets/lesson2/5.png",
      "lib/assets/lesson2/6.png",
      "lib/assets/lesson2/7.png",
      "lib/assets/lesson2/8.png",
      "lib/assets/lesson2/9.png",
      "lib/assets/lesson2/10.png",
      "lib/assets/lesson2/11.png",
      "lib/assets/lesson2/12.png",
      "lib/assets/lesson2/13.png",
      "lib/assets/lesson2/14.png",
      "lib/assets/lesson2/15.png",
      "lib/assets/lesson2/16.png",
      "lib/assets/lesson2/17.png",
      "lib/assets/lesson2/18.png",
      "lib/assets/lesson2/19.png",
      "lib/assets/lesson2/20.png",
      "lib/assets/lesson2/21.png",
      "lib/assets/lesson2/22.png",
      "lib/assets/lesson2/23.png",
      "lib/assets/lesson2/24.png",
      "lib/assets/lesson2/25.png",
      "lib/assets/lesson2/26.png",
      "lib/assets/lesson2/27.png",
      "lib/assets/lesson2/28.png",
      "lib/assets/lesson2/29.png",
      "lib/assets/lesson2/30.png",
      "lib/assets/lesson2/31.png",
      "lib/assets/lesson2/32.png",
      "lib/assets/lesson2/33.png",
      "lib/assets/lesson2/34.png",
      "lib/assets/lesson2/35.png",
      "lib/assets/lesson2/36.png",
      "lib/assets/lesson2/37.png",
      "lib/assets/lesson2/38.png",
      "lib/assets/lesson2/39.png",
      "lib/assets/lesson2/40.png",
    ],
    [
      "lib/assets/lesson3/1.png",
          "lib/assets/lesson3/2.png",
          "lib/assets/lesson3/3.png",
          "lib/assets/lesson3/4.png",
          "lib/assets/lesson3/5.png",
          "lib/assets/lesson3/6.png",
          "lib/assets/lesson3/7.png",
          "lib/assets/lesson3/8.png",
          "lib/assets/lesson3/9.png",
          "lib/assets/lesson3/10.png",
          "lib/assets/lesson3/11.png",
          "lib/assets/lesson3/12.png",
          "lib/assets/lesson3/13.png",
          "lib/assets/lesson3/14.png",
          "lib/assets/lesson3/15.png",
          "lib/assets/lesson3/16.png",
          "lib/assets/lesson3/17.png",
          "lib/assets/lesson3/18.png",
          "lib/assets/lesson3/19.png",
          "lib/assets/lesson3/20.png",
          "lib/assets/lesson3/21.png",
          "lib/assets/lesson3/22.png",
          "lib/assets/lesson3/23.png",
          "lib/assets/lesson3/24.png",
          "lib/assets/lesson3/25.png",
          "lib/assets/lesson3/26.png",
          "lib/assets/lesson3/27.png",
          "lib/assets/lesson3/28.png",
          "lib/assets/lesson3/29.png",
          "lib/assets/lesson3/30.png",
          "lib/assets/lesson3/31.png",
          "lib/assets/lesson3/32.png",
          "lib/assets/lesson3/33.png",
          "lib/assets/lesson3/34.png",
          "lib/assets/lesson3/35.png",
          "lib/assets/lesson3/36.png",
          "lib/assets/lesson3/37.png",
          "lib/assets/lesson3/38.png",
          "lib/assets/lesson3/39.png",
          "lib/assets/lesson3/40.png",
          "lib/assets/lesson3/41.png",
          "lib/assets/lesson3/42.png",
          "lib/assets/lesson3/43.png",
          "lib/assets/lesson3/44.png",
          "lib/assets/lesson3/45.png",
          "lib/assets/lesson3/46.png",
          "lib/assets/lesson3/47.png",
          "lib/assets/lesson3/48.png",
          "lib/assets/lesson3/49.png",
          "lib/assets/lesson3/50.png",
          "lib/assets/lesson3/51.png",
          "lib/assets/lesson3/52.png",
          "lib/assets/lesson3/53.png",
          "lib/assets/lesson3/54.png",
          "lib/assets/lesson3/55.png",
          "lib/assets/lesson3/56.png",
          "lib/assets/lesson3/57.png",
          "lib/assets/lesson3/58.png",
          "lib/assets/lesson3/59.png",
          "lib/assets/lesson3/60.png",
          "lib/assets/lesson3/61.png",
          "lib/assets/lesson3/62.png",
          "lib/assets/lesson3/63.png",
          "lib/assets/lesson3/64.png",
          "lib/assets/lesson3/65.png",
          "lib/assets/lesson3/66.png",
          "lib/assets/lesson3/67.png",
          "lib/assets/lesson3/68.png",
          "lib/assets/lesson3/69.png",
          "lib/assets/lesson3/70.png",
          "lib/assets/lesson3/71.png",
          "lib/assets/lesson3/72.png",
          "lib/assets/lesson3/73.png",
          "lib/assets/lesson3/74.png",
          "lib/assets/lesson3/75.png",
          "lib/assets/lesson3/76.png",
          "lib/assets/lesson3/77.png",
          "lib/assets/lesson3/78.png",
    ],
    [
      "lib/assets/lesson4/1.png",
          "lib/assets/lesson4/2.png",
          "lib/assets/lesson4/3.png",
          "lib/assets/lesson4/4.png",
          "lib/assets/lesson4/5.png",
          "lib/assets/lesson4/6.png",
          "lib/assets/lesson4/7.png",
          "lib/assets/lesson4/8.png",
          "lib/assets/lesson4/9.png",
          "lib/assets/lesson4/10.png",
          "lib/assets/lesson4/11.png",
          "lib/assets/lesson4/12.png",
          "lib/assets/lesson4/13.png",
          "lib/assets/lesson4/14.png",
          "lib/assets/lesson4/15.png",
          "lib/assets/lesson4/16.png",
          "lib/assets/lesson4/17.png",
          "lib/assets/lesson4/18.png",
          "lib/assets/lesson4/19.png",
          "lib/assets/lesson4/20.png",
          "lib/assets/lesson4/21.png",
          "lib/assets/lesson4/22.png",
          "lib/assets/lesson4/23.png",
          "lib/assets/lesson4/24.png",
          "lib/assets/lesson4/25.png",
          "lib/assets/lesson4/26.png",
          "lib/assets/lesson4/27.png",
          "lib/assets/lesson4/28.png",
          "lib/assets/lesson4/29.png",
          "lib/assets/lesson4/30.png",
          "lib/assets/lesson4/31.png",
          "lib/assets/lesson4/32.png",
          "lib/assets/lesson4/33.png",
          "lib/assets/lesson4/34.png",
          "lib/assets/lesson4/35.png",
          "lib/assets/lesson4/36.png",
          "lib/assets/lesson4/37.png",
          "lib/assets/lesson4/38.png",
          "lib/assets/lesson4/39.png",
          "lib/assets/lesson4/40.png",
          "lib/assets/lesson4/41.png",
          "lib/assets/lesson4/42.png",
          "lib/assets/lesson4/43.png",
          "lib/assets/lesson4/44.png",
          "lib/assets/lesson4/45.png",
          "lib/assets/lesson4/46.png",
          "lib/assets/lesson4/47.png",
          "lib/assets/lesson4/48.png",
          "lib/assets/lesson4/49.png",
          "lib/assets/lesson4/50.png",
          "lib/assets/lesson4/51.png",
          "lib/assets/lesson4/52.png",
          "lib/assets/lesson4/53.png",
          "lib/assets/lesson4/54.png",
          "lib/assets/lesson4/55.png",
          "lib/assets/lesson4/56.png",
          "lib/assets/lesson4/57.png",
          "lib/assets/lesson4/58.png",
          "lib/assets/lesson4/59.png",
          "lib/assets/lesson4/60.png",
          "lib/assets/lesson4/61.png",
          "lib/assets/lesson4/62.png",
          "lib/assets/lesson4/63.png",
          "lib/assets/lesson4/64.png",
          "lib/assets/lesson4/65.png",
          "lib/assets/lesson4/66.png",
          "lib/assets/lesson4/67.png",
          "lib/assets/lesson4/68.png",
          "lib/assets/lesson4/69.png",
          "lib/assets/lesson4/70.png",
          "lib/assets/lesson4/71.png",
          "lib/assets/lesson4/72.png",
          "lib/assets/lesson4/73.png",
          "lib/assets/lesson4/74.png",
          "lib/assets/lesson4/75.png",
          "lib/assets/lesson4/76.png",
          "lib/assets/lesson4/77.png",
          "lib/assets/lesson4/78.png",
          "lib/assets/lesson4/79.png",
          "lib/assets/lesson4/80.png",
          "lib/assets/lesson4/81.png",
          "lib/assets/lesson4/82.png",
          "lib/assets/lesson4/83.png",
          "lib/assets/lesson4/84.png",
          "lib/assets/lesson4/85.png",
          "lib/assets/lesson4/86.png",
          "lib/assets/lesson4/87.png",
          "lib/assets/lesson4/88.png",
          "lib/assets/lesson4/89.png",
          "lib/assets/lesson4/90.png",
          "lib/assets/lesson4/91.png",
          "lib/assets/lesson4/92.png",
          "lib/assets/lesson4/93.png",
          "lib/assets/lesson4/94.png",
    ],
    [
      "lib/assets/lesson5/1.png",
      "lib/assets/lesson5/2.png",
      "lib/assets/lesson5/3.png",
      "lib/assets/lesson5/4.png",
      "lib/assets/lesson5/5.png",
      "lib/assets/lesson5/6.png",
      "lib/assets/lesson5/7.png",
      "lib/assets/lesson5/8.png",
      "lib/assets/lesson5/9.png",
      "lib/assets/lesson5/10.png",
      "lib/assets/lesson5/11.png",
      "lib/assets/lesson5/12.png",
      "lib/assets/lesson5/13.png",
      "lib/assets/lesson5/14.png",
      "lib/assets/lesson5/15.png",
      "lib/assets/lesson5/16.png",
      "lib/assets/lesson5/17.png",
      "lib/assets/lesson5/18.png",
      "lib/assets/lesson5/19.png",
      "lib/assets/lesson5/20.png",
      "lib/assets/lesson5/21.png",
      "lib/assets/lesson5/22.png",
      "lib/assets/lesson5/23.png",
      "lib/assets/lesson5/24.png",
      "lib/assets/lesson5/25.png",
      "lib/assets/lesson5/26.png",
      "lib/assets/lesson5/27.png",
      "lib/assets/lesson5/28.png",
      "lib/assets/lesson5/29.png",
      "lib/assets/lesson5/30.png",
      "lib/assets/lesson5/31.png",
      "lib/assets/lesson5/32.png",
      "lib/assets/lesson5/33.png",
      "lib/assets/lesson5/34.png",
      "lib/assets/lesson5/35.png",
      "lib/assets/lesson5/36.png",
      "lib/assets/lesson5/37.png",
      "lib/assets/lesson5/38.png",
      "lib/assets/lesson5/39.png",
      "lib/assets/lesson5/40.png",
      "lib/assets/lesson5/41.png",
      "lib/assets/lesson5/42.png",
      "lib/assets/lesson5/43.png",
      "lib/assets/lesson5/44.png",
      "lib/assets/lesson5/45.png",
      "lib/assets/lesson5/46.png",
      "lib/assets/lesson5/47.png",
      "lib/assets/lesson5/48.png",
    ],
    [
      "lib/assets/lesson6/1.png",
      "lib/assets/lesson6/2.png",
      "lib/assets/lesson6/3.png",
      "lib/assets/lesson6/4.png",
      "lib/assets/lesson6/5.png",
      "lib/assets/lesson6/6.png",
      "lib/assets/lesson6/7.png",
      "lib/assets/lesson6/8.png",
      "lib/assets/lesson6/9.png",
      "lib/assets/lesson6/10.png",
      "lib/assets/lesson6/11.png",
      "lib/assets/lesson6/12.png",
      "lib/assets/lesson6/13.png",
      "lib/assets/lesson6/14.png",
      "lib/assets/lesson6/15.png",
      "lib/assets/lesson6/16.png",
      "lib/assets/lesson6/17.png",
      "lib/assets/lesson6/18.png",
      "lib/assets/lesson6/19.png",
      "lib/assets/lesson6/20.png",
      "lib/assets/lesson6/21.png",
      "lib/assets/lesson6/22.png",
      "lib/assets/lesson6/23.png",
      "lib/assets/lesson6/24.png",
    ],
    [
      "/lib/assets/lesson7/1.png",
      "/lib/assets/lesson7/2.png",
      "/lib/assets/lesson7/3.png",
      "/lib/assets/lesson7/4.png",
      "/lib/assets/lesson7/5.png",
      "/lib/assets/lesson7/6.png",
      "/lib/assets/lesson7/7.png",
      "/lib/assets/lesson7/8.png",
      "/lib/assets/lesson7/9.png",
      "/lib/assets/lesson7/10.png",
      "/lib/assets/lesson7/11.png",
      "/lib/assets/lesson7/12.png",
      "/lib/assets/lesson7/13.png",
      "/lib/assets/lesson7/14.png",
      "/lib/assets/lesson7/15.png",
      "/lib/assets/lesson7/16.png",
      "/lib/assets/lesson7/17.png",
      "/lib/assets/lesson7/18.png",
      "/lib/assets/lesson7/19.png",
      "/lib/assets/lesson7/20.png",
      "/lib/assets/lesson7/21.png",
      "/lib/assets/lesson7/22.png",
      "/lib/assets/lesson7/23.png",
      "/lib/assets/lesson7/24.png",
      "/lib/assets/lesson7/25.png",
      "/lib/assets/lesson7/26.png",
      "/lib/assets/lesson7/27.png",
      "/lib/assets/lesson7/28.png",
      "/lib/assets/lesson7/29.png",
      "/lib/assets/lesson7/30.png",
      "/lib/assets/lesson7/31.png",
      "/lib/assets/lesson7/32.png",
      "/lib/assets/lesson7/33.png",
      "/lib/assets/lesson7/34.png",
      "/lib/assets/lesson7/35.png",
      "/lib/assets/lesson7/36.png",
      "/lib/assets/lesson7/37.png",
      "/lib/assets/lesson7/38.png",
      "/lib/assets/lesson7/39.png",
      "/lib/assets/lesson7/40.png",
      "/lib/assets/lesson7/41.png",
      "/lib/assets/lesson7/42.png",
      "/lib/assets/lesson7/43.png",
      "/lib/assets/lesson7/44.png",
      "/lib/assets/lesson7/45.png",
    ],
    [
      "/lib/assets/lesson8/1.png",
      "/lib/assets/lesson8/2.png",
      "/lib/assets/lesson8/3.png",
      "/lib/assets/lesson8/4.png",
      "/lib/assets/lesson8/5.png",
      "/lib/assets/lesson8/6.png",
      "/lib/assets/lesson8/7.png",
      "/lib/assets/lesson8/8.png",
      "/lib/assets/lesson8/9.png",
      "/lib/assets/lesson8/10.png",
      "/lib/assets/lesson8/11.png",
      "/lib/assets/lesson8/12.png",
      "/lib/assets/lesson8/13.png",
      "/lib/assets/lesson8/14.png",
      "/lib/assets/lesson8/15.png",
      "/lib/assets/lesson8/16.png",
      "/lib/assets/lesson8/17.png",
      "/lib/assets/lesson8/18.png",
      "/lib/assets/lesson8/19.png",
      "/lib/assets/lesson8/20.png",
      "/lib/assets/lesson8/21.png",
      "/lib/assets/lesson8/22.png",
      "/lib/assets/lesson8/23.png",
      "/lib/assets/lesson8/24.png",
      "/lib/assets/lesson8/25.png",
      "/lib/assets/lesson8/26.png",
    ],

  ];

  List<List> lesson2 = [
    [
      "/lib/assets/lesson9/1.png",
      "/lib/assets/lesson9/2.png",
      "/lib/assets/lesson9/3.png",
      "/lib/assets/lesson9/4.png",
      "/lib/assets/lesson9/5.png",
      "/lib/assets/lesson9/6.png",
      "/lib/assets/lesson9/7.png",
      "/lib/assets/lesson9/8.png",
      "/lib/assets/lesson9/9.png",
      "/lib/assets/lesson9/10.png",
      "/lib/assets/lesson9/11.png",
      "/lib/assets/lesson9/12.png",
      "/lib/assets/lesson9/13.png",
      "/lib/assets/lesson9/14.png",
      "/lib/assets/lesson9/15.png",
      "/lib/assets/lesson9/16.png",
      "/lib/assets/lesson9/17.png",
      "/lib/assets/lesson9/18.png",
      "/lib/assets/lesson9/19.png",
      "/lib/assets/lesson9/20.png",
      "/lib/assets/lesson9/21.png",
      "/lib/assets/lesson9/22.png",
      "/lib/assets/lesson9/23.png",
      "/lib/assets/lesson9/24.png",
      "/lib/assets/lesson9/25.png",
      "/lib/assets/lesson9/26.png",
      "/lib/assets/lesson9/27.png",
      "/lib/assets/lesson9/28.png",
      "/lib/assets/lesson9/29.png",
      "/lib/assets/lesson9/30.png",
    ],
    [
      "/lib/assets/lesson10/1.png",
      "/lib/assets/lesson10/2.png",
      "/lib/assets/lesson10/3.png",
      "/lib/assets/lesson10/4.png",
      "/lib/assets/lesson10/5.png",
      "/lib/assets/lesson10/6.png",
      "/lib/assets/lesson10/7.png",
      "/lib/assets/lesson10/8.png",
      "/lib/assets/lesson10/9.png",
      "/lib/assets/lesson10/10.png",
      "/lib/assets/lesson10/11.png",
      "/lib/assets/lesson10/12.png",
      "/lib/assets/lesson10/13.png",
      "/lib/assets/lesson10/14.png",
      "/lib/assets/lesson10/15.png",
      "/lib/assets/lesson10/16.png",
      "/lib/assets/lesson10/17.png",
      "/lib/assets/lesson10/18.png",
      "/lib/assets/lesson10/19.png",
      "/lib/assets/lesson10/20.png",
      "/lib/assets/lesson10/21.png",
      "/lib/assets/lesson10/22.png",
      "/lib/assets/lesson10/23.png",
      "/lib/assets/lesson10/24.png",
      "/lib/assets/lesson10/25.png",
      "/lib/assets/lesson10/26.png",
      "/lib/assets/lesson10/27.png",
      "/lib/assets/lesson10/28.png",
      "/lib/assets/lesson10/29.png",
      "/lib/assets/lesson10/30.png",
      "/lib/assets/lesson10/31.png",
      "/lib/assets/lesson10/32.png",
      "/lib/assets/lesson10/33.png",
      "/lib/assets/lesson10/34.png",
      "/lib/assets/lesson10/35.png",
    ],
    [
      "/lib/assets/lesson11/1.png",
      "/lib/assets/lesson11/2.png",
      "/lib/assets/lesson11/3.png",
      "/lib/assets/lesson11/4.png",
      "/lib/assets/lesson11/5.png",
      "/lib/assets/lesson11/6.png",
      "/lib/assets/lesson11/7.png",
      "/lib/assets/lesson11/8.png",
      "/lib/assets/lesson11/9.png",
      "/lib/assets/lesson11/10.png",
      "/lib/assets/lesson11/11.png",
      "/lib/assets/lesson11/12.png",
      "/lib/assets/lesson11/13.png",
      "/lib/assets/lesson11/14.png",
      "/lib/assets/lesson11/15.png",
      "/lib/assets/lesson11/16.png",
      "/lib/assets/lesson11/17.png",
      "/lib/assets/lesson11/18.png",
      "/lib/assets/lesson11/19.png",
      "/lib/assets/lesson11/20.png",
      "/lib/assets/lesson11/21.png",
      "/lib/assets/lesson11/22.png",
      "/lib/assets/lesson11/23.png",
      "/lib/assets/lesson11/24.png",
      "/lib/assets/lesson11/25.png",
      "/lib/assets/lesson11/26.png",
      "/lib/assets/lesson11/27.png",
      "/lib/assets/lesson11/28.png",
      "/lib/assets/lesson11/29.png",
      "/lib/assets/lesson11/30.png",
      "/lib/assets/lesson11/31.png",
      "/lib/assets/lesson11/32.png",
      "/lib/assets/lesson11/33.png",
      "/lib/assets/lesson11/34.png",
      "/lib/assets/lesson11/35.png",
      "/lib/assets/lesson11/36.png",
    ]
  ];

  List<List> content = [
    [
      "\nSOFTWARE,"
      "\n\nSoftware is defined as a collection of programs, documentation and operating procedures. The Institute of Electrical and Electronic Engineers (IEEE) defines software as a 'collection of computer programs, procedures, rules and associated documentation and data' It possesses no mass, no volume, and no colour, which makes it a non-degradable entity over a long period. Software does not wear out or get tired."
      "\nSoftware controls, integrates, and manages the hardware components of a computer system. It also instructs the computer what needs to be done to perform a specific task and how it is to be done. For example, software instructs the hardware how to print a document, take input from the user, and display the output."
      "\nComputer works only in response to instructions provided externally. Usually, the instructions to perform some intended tasks are organized into a program using a programming language like C, C++, Java, etc., and submitted to computer. Computer interprets and executes these instructions and provides response to the user accordingly. A set of programs intended to provide users with a set of interrelated functionalities is known as a software package. For example, an accounting software package such as Tally provides users the functionality to perform accounting-related activities."
      "\n\nSoftware Characteristics"
      "\n\nDifferent individuals judge software on different basis. This is because they are involved with the software in different ways. For example, users want the software to perform according to their requirements. Similarly, developers involved in designing, coding, and maintenance of the software evaluate the software by looking at its internal characteristics, before delivering it to the user."
      "\n• Functionality: Refers to the degree of performance of the software against its intended purpose."
      "\n• Reliability: Refers to the ability of the software to provide desired functionality under the given conditions."
      "\n• Usability: Refers to the extent to which the software can be used with ease"
      "\n• Efficiency: Refers to the ability of the software to use system resources in the most effective and efficient manner."

      "\n• Maintainability: Refers to the case with which the modifications can be made in a software system to extend its functionality, improve its performance, or correct errors."

      "\n• Portability: Refers to the case with which software developers can transfer software from one platform to another, without (or with minimum) changes. In simple terms, it refers to the ability of software to function properly on different hardware and software platforms without making any changes in it."
      "\nIn addition to the above mentioned characteristics, robustness and integrity are also important. Robustness refers to the degree to which the software can keep on functioning in spite of being provided with invalid data while integrity refers to the degree to which unauthorized access to the software or data can be prevented."

      "\n\nClassification of Software"

      "\n\nSoftware can be applied in countless fields such as business, education, social sector, and other fields. It is designed to suit some specific goals such as data processing, information sharing, communication, and so on. It is classified according to the range of potential of applications. These classifications are listed below."

      "\n• System software: This class of software manages and controls the internal operations of a computer system, It is a group of programs, which is responsible for using computer resources efficiently and effectively. For example, an operating system is a system software, which controls the hardware, manages memory and multitasking functions, and acts as an interface between application prograins and the computer."
      "\n• Real-time software: This class of software observes, analyzes, and controls real world events as they occur. Generally, a real-time stem guarantees a response to an external event within a specified period of time. An example of real-time software is the software used for weather forecasting that collects and processes parameters like temperature and humidity from the external environment to forecast the weather. Most of the defence organizations all over the world use real-time software to control their military hardware."

  "\n• Business software: This class of software is widely used in areas where management and control of financial activities is of utmost importance. The fundamental component of a business system comprises payroll, inventory. and accounting software that permit the user to access relevant data from the database. These activities are usually performed with the help of specialized business software that facilitates efficient framework in business operations and in management decisions."

  "\n• Engineering and scientific software: This class of software has emerged as a powerful tool in the research and development of next generation technology. Applications such as the study of celestial bodies, under surface activities, and programming of an orbital path for space shuttles are heavily dependent on engineering and scientific software. This software is designed to perform precise calculations on complex numerical data that are obtained during real-time environment."

  "\n• Artificial intelligence (AI) software: This class of software is used where the problem-solving technique is non-algorithmic in nature. The solutions of such problems are generally non-agreeable to computation or straightforward\" analysis. Instead, these problems require specific problem-solving strategies that include expert system, pattern recognition, and game-playing techniques, In addition, they involve different kinds of search techniques which include the use of heuristics. The role of artificial intelligence software is to add certain degrees of intelligence to the mechanical hardware in order to get the desired work done in an agile manner."

  "\n• Web-based software: This class of software acts as an interface between the user and the Internet. Data on the Internet is in the form of text, audio, or video format, linked with hyperlinks. Web browser is a software that retrieves web pages from the Internet. The software incorporates executable instructions written in special scripting languages such as CGI or ASP. Apart from providing navigation on the Web, this software also supports additional features that are useful while surfing the Internet."
  "\n• Personal computer (PC) software: This class of software is used for both official and personal use. The personal computer software market has grown over in the last two decades from normal text editor to word processor and from simple paintbrush to advanced image-editing software. This software is used predominantly in almost every field, whether it is database management system, financial accounting package, or multimedia-based software. It has emerged as a versatile tool for routine applications."
  "\nManagement Myths"
  "\nIn most cases, users tend to believe myths about the software because software managers and developers do not try to correct the false beliefs. These myths lead to false expectations and ultimately develop dissatisfaction among the user"
  "\n\nUser Myths"
  "\n\nIn the early days of software development, programming was viewed as an art, but now software development has gradually become an engineering discipline. However, developers still believe in some myths. Some of the common developer myths are listed"
  "\n\nSoftware Crisis"
  "\n\nIn the late 1960s, it became clear that the development of software is different from manufacturing other products. This is because employing more manpower (programmers) later in the software development does not always help speed up the development process. Instead, sometimes it may have negative impacts like delay in achieving the scheduled targets, degradation of software quality, etc. Though software has been an important elenent of many systems since a long time. developing software within a certain schedule and maintaining its quality is still difficult."
  "\nHistory has seen that delivering software after the scheduled date or with errors has caused large scale financial losses as well as inconvenience to many. Disasters such as the Y2K problem affected economic, political, and administrative systems of various countries around the world. This situation, where catastrophic faiiures have occurred, is known as software crisis. The major causes of software crisis are the problems associated with poor quality software such as malfunctioning of software systems, inefficient development of software, and the most important, dissatisfaction amongst the users of the software."
  "\nThe software market today has a turnover of more than millions of rupees. Oui of this, approximately thirty Percent of software is used for personal computers and the remaining software is developed for specific users or organizations. Application areas such as the banking sector are completely dependant on software application. Software failures in these technology-oriented areas have led to considerable loss in terms of time, money, and even human lives. History has been witness to many such failures, some of which are listed below."
    ],
    [
  "\nChapter 2: Software Development Life Cycle (SDLC)"
  "\n\nSoftware Development Life Cycle"
  "\n	Software Development Life Cycle is the application of standard business practices to building software applications."
  "\n	It’s typically divided into six to eight steps:"

  "\n1.	Planning"
  "\n2.	Requirements"
  "\n3.	Design"
  "\n4.	Build"
  "\n5.	Document"
  "\n6.	Test"
  "\n7.	Deploy"
  "\n8.	Maintain"

  "\n\nHow the Software Development Life Cycle Works?"
  "\n	The Software Development Life Cycle simply outlines each task required to put together a software application."
  "\n	This helps to reduce waste and increase the efficiency of the development process."
  "\n	Monitoring also ensures the project stays on track, and continues to be a feasible investment for the company."
  "\n	Many companies will subdivide these steps into smaller units."
  "\n	Planning might be broken into technology research, marketing research, and a cost-benefit analysis."
  "\n	Other steps can merge with each other, the Testing Phase can run concurrently with the Development phase, since developers need to fix errors that occur during testing."

  "\n\nThe Phases of SDLC"
  "\n(Systems Development Life Cycle)"

  "\n\n1st Phase: Planning"
  "\n	In the planning phase, project leaders evaluate the terms of the project. This includes calculating labor and material costs, creating a timetable with target goals, and creating the project’s teams and leadership structure."
  "\n	Planning can also include feedback from stakeholders. Stakeholders are anyone who stands to benefit from the application. Try to get feedback from potential customers, developers, subject matter experts, and sales reps."
  "\n	Planning should clearly define the scope and purpose of the application. It plots the course and provisions the team to effectively create the software. It also sets boundaries to help keep the project from expanding or shifting from its original purpose."
  "\n2nd Phase: Defining Requirements"
  "\n	Defining requirements is considered part of planning to determine what the application is supposed to do and its requirements."
  "\n		For example, a social media application would require the ability to connect with a friend. An inventory program might require a search feature."
  "\n	Requirements also include defining the resources needed to build the project. For example, a team might develop software to control a custom manufacturing machine. The machine is a requirement in the process."

  "\n3rd Phase: Software Design & Prototyping"
  "\n	consists of standardized patterns used for both architecture and software development."
  "\n	design patterns also allow solving algorithmic problems consistently."
  "\n\nAspects of the Design"

  "\n1.	Architecture"
  "\n2.	User Interface"
  "\n3.	Platforms"
  "\n4.	Programming"
  "\n5.	Communication"
  "\n6.	 Security"

  "\nArchitecture - specifies programming language, industry practices, overall design, and use of any templates or boilerplate."
  "\nUser Interface - defines the way customers interact with the software, and how the software responds to input."
  "\nPlatform - defines the platforms on which the software will run, such as Apple, Android, Windows version, Linux, or even gaming consoles."

  "\nProgramming - not just the programming language, but including methods of solving problems and performing tasks in the application."
  "\nCommunications -  defines the methods that the application can communicate with other assets, such as a central server or other instances of the application."
  "\nSecurity - Defines the measures taken to secure the application, and may include SSL traffic encryption, password protection, and secure storage of user credentials."

  "\n\nPROTOTYPING"
  "\n	part of the design phase."
  "\n	one of the early versions of software in the Iterative software development model."
  "\n	this “hands-on” design can be shown to stakeholders."

  "\n\n4th Phase: Developing the Software"
  "\n	in this phase, the developers or development team is busy coding the software."
  "\n	depending on the methodology, the process might either be carried out in time-boxed sprints or follow a single block of effort."
  "\n	finding and fixing errors and glitches is critical."
  "\n	Software developers appreciate instructions and explanations."

  "\n\n5th Phase: Testing the Software"
  "\n	Once the software is complete, and it is deployed in the testing environment."
  "\n	The testing team starts testing the functionality of the entire system. This is done to verify that the entire application works according to the customer requirement."
  "\n6th Phase: Installation/Deployment"

  "\n	Once the software testing phase is over and no bugs or errors left in the system then the final deployment process starts."
  "\n	Based on the feedback given by the project manager, the final software is released and checked for deployment issues if any."

  "\n\n7th Phase: Maintenance"
  "\nOnce the system is deployed, and customers start using the developed system, following 3 activities occur:"
  "\na.) Bug fixing."
  "\nb.) Upgrade."
  "\nc.) Enhancement."

  "\n\nSDLC Models"

  "\nTo help understand and implement the SDLC phases various SDLC Models have been created by software developments experts, universities, and standard organizations."
  "\nReasons for Using SDLC Models"
  "\n1.	Provides the base for project planning, estimating and scheduling."
  "\n2.	Provides framework for standards set of terminologies, activities and deliverables."
  "\n3.	Provides mechanism for project tracking and control."
  "\n4.	Increases visibility of project progress to all stakeholders."

  "\n\nSDLC Models"
  "\n\nAdvantages of Choosing an Appropriate SDLC"
  "\n•	Increased development speed"
  "\n•	Increased product quality"
  "\n•	Improved tracking and control"
  "\n•	Improved client relations"
  "\n•	Decreased project risk"
  "\n•	Decreased project management overhead"

  "\n\nThe WATERFALL Model"
  "\n•	Waterfall Model is a sequential model that divides software development into pre-defined phases."
  "\n•	Each phase must be completed before the next phase can begin with no overlap between the phases."
  "\n•	Each phase is designed for performing specific activity during the SDLC phase."
  "\n•	It was introduced in 1970 by Winston Royce."
  "\nin the waterfall model (also known as the classical life cycle model), the development of software proceeds linearly and sequentially from requirement analysis to design, coding, testing, integration, implementation, and maintenance. Thus, this model is also known as the linear sequential model."
  "\nRapid Application Development (RAD) Model"
  "\nThe rapid application development model emphasizes on delivering projects in small pieces. If the project is large, it is divided into a series of smaller projects. Each of these smaller projects is planned and delivered individually. Thus, with a series of smaller projects, the final project is delivered quickly and in a less structured manner"
  ],
    [
  "\nChapter 3 Software Requirements"
  "\nOBJECTIVES"
  "\nTo introduce the concepts of user and system requirements."
  "\nTo describe the three classes of requirements(functional, non-functional and domain)."
  "\nTo explain the software engineering process."
  "\nTOPICS"
  "\n1.	Software Requirements"
  "\n2.	User and System Requirements"
  "\n3.	Functional, non-functional and domain requirements"
  "\n4.	Requirements Engineering process"

  "\nWHAT IS SOFTWARE REQUIREMENT?"
  "\nRequirement is a condition or capability possessed by the software or system component in order to solve a real world problem. The problems can be to automate a part of a system, to correct shortcomings of an existing system, to control a device, and so on. IEEE defines requirement as (1) A condition or capability needed by a user to solve a problem or achieve an objective. (2) A condition or capability that must be met or possessed by a system or system component to satisfy a contract, standard, specification, or other formally imposed documents. (3) A documented representation of a condition or capability as in (1) or (2)."
  "\nRequirements describe how a system should act, appear or perform. For this, when users request for software, they provide an approximation of what the new system should be capable of doing. Requirements differ from one user to another and from one business process to another."
  "\nIEEE"
  "\nIEEE defines functional requirements as 'a function that a system or component must be able to perform. These requirements describe the interaction of software with its environment and specify the inputs, outputs, external interfaces, and the functions that should be included in the software. Also, the services provided by functional requirements specify the procedure by which the software should react to particular inputs or behave in particular situations"
  "\nTo understand functional requirements properly, let us consider the following example of an online banking system."
  "\n• The user of the bank should be able to search the desired services from the available ones."
  "\n• There should be appropriate documents for users to read. This implies that when a user wants to open an account in the bank, the forms must be available so that the user can open an account."
  "\n• After registration, the user should be provided with a unique acknowledgement number so that he can later be given an account nuraber."
  "\nThe above mentioned functional requirements describe the specific services provided by the online banking system. These requirements indicate user requirements and specify that functional requirements may be described at different levels of detail in an online banking system. With the help of these functional requirements, users can easily view, search and downioad registration forms and other information about the bank. On the other hand, if requirements are not stated properly, they are misinterpreted by software engineers and user requirements are not met"
  "\nThe functional requirements should be complete and consistent. Completeness implies that all the user requirements are defined. Consistency implies that all requirements are speciñed"
  "\nclearly without any contradictory definition. Generally, it is observed that completeness and consistency cannot be achieved in large software or in a complex system due to the problems that arise while defiring the functional requirements of these systems. The different needs of stakeholders also prevent the achievement of completeness and consistency. Due to these reasons, requirements may not be obvious when they are first specified and may further lead to inconsistencies in the requirements specification."
  "\nThe non-functional requirements (also known as quality requirements) are related to system attributes such as reliability and response time. Non-functional requirements arise due to user requirements, budget constraints, organizational policies, and so on. These requirements are not related directly to any particuler function provided by the system"
  "\nNon-functional requirements should be accomplished in software to make it perform efficiently. For example, if an aeroplane is unable to fulfill reliability requirements, it is not approved for safe operation. Similarly, if a real time control system is ineffective in accomplishing non-functional requirements, the control functions cannot operate correctly. Different types of non-functional requirements"
  "\nThe description of different types of non-functional requirements is listed below."
  "\n• Product requirements: These requirements specify how software product performs. Product requirements comprise the following"
  "\n■Efficiency requirements: Describe the extent to which the software makes"
  "\noptimal use of resources, the speed with which the system executes, and the memory it consumes for its operation. For example, the system should be able to operate at least three times faster than the existing systeni"
  "\n■ Reliability requirements: Describe the acceptable failure rate of the software. For example, the software should be able to operate even if a hazard occurs."
  "\nFeasibility Study Process"
  "\nFeasibility study comprises the following steps."
  "\nInformation assessment: Identifies information about whether the system helps in achieving the objectives of the organization. It also verifies that the system can be in lemented using new technology and within the budget and whether the system can be integrated with the existing system."
  "\n• Information collection: Specifies the sources from where information about software can be obtained. Generally, these sources include users (who will operate the software), organization (where the software will be used), and the software development team (which understands user requirements and knows how to fulful them in software)."
  "\nReport writing: Uses a feasibility report, which is the conclusion of the feasibility study by the software development team. It includes the recommendations whether the software development should continue. This report may also include information about changes in the software scape, budget, and schedule and suggestions of any requiremenes in the system."
  "\n• General information: Describes the purpose and scope of feasibility study. It also describes system overview, project references, acronyms and abbreviations, and points of contact to be used. System overview provides description about the name of the organization responsible for the software development, system name or title, system category, operational status, and so on. Project references provide a list of the references used to prepare this document such as documents relating to the project or previously developed documents that are related to the project. Acronyms and abbreviations provide a list of the terms that are used in this document along with their meanings. Points of contact provide a list of points of organizational contact with users for information and coordination. For example, users require assistance to solve problems (such as troubleshooting) and collect information such as contact number, e-mail address, and so on."
  "\nManagement summary: Provides the following information."

  "\n■ Environment: Identifies the individuals responsible for software development. It provides information about input and output requirements, processing requirements of the software and the interaction of the software with other software. It also identifies system security requirements and the system's processing requirements"

  "\n■Current functional procedures: Describes the current functional procedures of the existing system, whether autoraated or manual. It also includes the data flow of the current system and the number of team members required to cperate and maintain the software."

  "\n■Functional objective: Provides information about functions of the system such as new services, increased capacity, and so on."
  "\n■Performance objective: Provides information about performance objectives such as reduced staff and equipment costs, increased processing speeds of software, and improved controls."
  "\n■Assumptions and constraints: Provides information about assumptions and constraints such as operational life of the proposed software, financial constraints, changing hardware, software and operating environment, and availability of information and sources."
  "\n■Methodology: Describes the methods that are applied to evaluate the proposed software in order to reach a feasible alternative. These methods include survey, modeling, benchmarking, etc."
  "\n■ Evaluation criteria: Identifies criteria such as cost, priority, development time, and ease of system use, which are applicable for the development process to determine the most suitable system option."
  "\n■Proposed software: Describes the overall concept of the system as well as the procedure to be used to meet user requirements. In addition, it provides information about improvements, time and resource costs, and impacts. Improvements are performed to enhance the functionality and performance of the existing software. Time and resource costs include the costs associated with software development from its requirements to its maintenance and staff training. Impacts describe the possibility of future happenings and include various types of impacts as listed below."
  "\n■Equipment impacts: Determine new equipment requirements and changes to be made in the currently available equipment requirements."
  "\nSoftware impacts: Specify any additions or modifications required in the existing software and supporting software to adapt to the proposed software."
  "\nOrganizational impacts: Describe any changes in organization, staff and skills requirement."
  "\n■ Operational impacts: Describe effects on operations such as user-operating procedures, data processing, data entry procedures, and so on."
  "\n• Developmental impacts: Specify developmental impacts such as resources required to develop databases, resources required to develop and test the software, and specific activities to be performed by users during software. development"
  "\n■Security impacts: Describe security factors that may influence the development, design, and continued operation of the proposed software."
  "\n• Alternative systems: Provide description of alternative systems, which are considered in a feasibility study. This also describes the reasons for choosing a particular alternative system to develop the proposed software and the reason for rejecting alternative systems."

  "\nREQUIREMENTS ELICITATION"
  "\nRequirements elicitation (also known as requirements capture and requirements acquisition) is a process of collecting information about software requirements from different individuals such as users and other stakeholders. Stakeholders are individuals who are affected by the system, directly or indirectly. They include project mangers, marketing personnel, consultants, software engineers, maintenance engineers, and the user."
  "\nVarious issues may arise during requirements elicitation and may cause difficulties in understanding the software requirements. Some of the problems are listed below."
  "\n• Problems of scope: This problem, arises when the boundary of software (that is, scope) is not defined properly. Due to this, it becomes difficult to identify objectives as well as functions and features to be included in the software."
  "\n• Problems of understanding: This problem arises when users are not certain about their requirements and thus are unable to express what they require in the software and which requirements are feasible. This problem also arises when users have no or little knowledge of the problem domain and are unable to understand the limitations of the computing environment of the software."
  "\n• Problems of volatility: This problem arises when requirements change over time."
  "\nRequirements elicitation uses elicitation techniques, which facilitate software engineers to understand user requirements and software requirements needed to develop the proposed software."
  ],
    [
  "\nCHAPTER 4: SOFTWARE DESIGN"

  "\nTABLE OF CONTENTS:"
  "\n4.1 Basics of Software Design"
  "\n4.2 Data Design"
  "\n4.3 Architectural Design"
  "\n4.4 Component-Level Design"
  "\n4.5 User Interface Design"
  "\n4.6 Graphical User Design"
  "\n4.7 Object-Oriented Design"
  "\n4.8 Software Design Notations"
  "\n4.9 Software Design Reviews"
  "\n4.10 Software Design Documentation"

  "\nBASICS OF SOFTWARE DESIGN"
  "\nSoftware design is a phase in software engineering, in which a blueprint is developed to serve as a base for constructing the software system. IEEE defines software design as 'both a process of defining the architecture, components, interfaces, and other characteristics of a system or component and the result of that process."
  "\nIn the design phase, many critical and strategic decisions are made to achieve the desired functionality and quality of the system. These decisions are taken into account to successfully develop the software and carry out its maintenance in a way that the quality of the end product is improved."
  "\nPrinciples of Software Design"
  "\nDeveloping design is a cumbersome process as most expansive errors are often introduced in this phase. Moreover, if these errors get unnoticed till later phases, it becomes more difficult to correct them. Therefore, a number of principles are followed while designing the software."
  "\nSoftware Design Concepts"
  "\nEvery software process is characterized by basic concepts along with certain practices or methods. Methods represent the manner through which the concepts are applied. As new technology replaces older technology, many changes occur in the methods that are used to apply the concepts for the development of software. However, the fundamental concepts underlining the software design process remain the same, some of which are described here."
  "\nAbstraction"
  "\nAbstraction refers to a powerful design tool, which allows software designers to consider components at an abstract level, while neglecting the implementation details of the components. IEEE defines abstraction as 'a view of a problem that extracts the essential information relevant to a particula: purpose and ignores the remainder of the information. The concept of abstraction can be used in two ways: as a process and as an entity. As a process, it refers to a mechanism of hiding irrelevant details and representing only the essential features of an item so that one can focus on important things at a time. As an entity, it refers to a model or view of an item."
  "\nEach step in the software process is accomplished through various levels of abstraction. At the highest level, an outline of the solution to the problem is presented whereas at the lower levels, the solution to the problem is presented in detail. For example, in the requirements analysis phase, a solution to the problem is presented using the language of problem environment and as we proceed through the software process, the abstraction level reduces and at the lowest level, source code of the software is produced."
  "\nThere are three commonly used abstraction mechanisms in software design, namely, functional abstraction, data abstraction and control abstraction. All these mechanisms allow us to control the complexity of the design process by proceeding from the abstract design model to concrete design model in a systematic manner."
  "\n✓✓ Functional abstraction: This involves the use of parameterized subprograms. Functional abstraction can be generalized as collections of subprograms referred to as 'groups'. Within these groups there exist routines which may be visible or hidden. Visible routines can be used within the containing groups as well as within other groups, whereas hidden routines are hidden from other groups and can be used within the containing group only."
  "\nData abstraction: This involves specifying data that describes a data object. For example, the data object window encompasses a set of attributes (windowtype, window dimension) that describe the window object clearly. In this abstraction mechanism, representation and manipulation details are ignored."
  "\n• Control abstraction: This states the desired effect, without stating the exact mechanism of control. For example, if and while statements in programming languages (like C and C++) are abstractions of machine code implementations, which involve conditional instructions. In the architectural design level, this abstraction mechanism permits specifications of sequer.tial subprogram and exception handlers without the concern for exact details of implementation."
  "\nARCHIECTURAL DESIGN"
  "\nRequirements of the software should be transformed into an architecture that describes the software's top-levei structure and identifies its components. This is accomplished through architectural design (also called system design), which acts as a preliminary \"blueprint' from which software can be developed. IEEE defines architectural design as 'the process of defining a collection of hardware and software components and their interfaces to establish the framework for the development of a computer system. This framework is established by examining the software requirements document and designing a model for providing implementation details. These details are used to specify the components of the system along with their"
  "\ninputs, outputs, functions, and the interaction between them. An architectural design performs the following functions."
  "\n• It defines an abstraction level at which the designers can specify the functional and performance behaviour of the system."
  "\n• It acts as a guideline for enhancing the system (whenever required) by describing those features of the system that can be modified easily without affecting the system integrity."
  "\n• It evaluates all top-level designs."
  "\nIt develops and documents top-level design for the external and internal interfaces."

  ],
    [
  "\nChapter #5 SOFTWARE CODING"

  "\nTABLE OF CONTENTS"
  "\n•	CHAPTER OBJECTIVES"
  "\n•	FEATURES OF SOFTWARE CODES"
  "\n•	CODING GUIDELINES & METHODOLOGY"
  "\n•	PROGRAMMING PRACTICE"
  "\n•	CODE VERIFICATION TECHNIQUES"
  "\n•	CODING TOOLS"
  "\n•	CODE DOCUMENTATION"

  "\nCHAPTER OBJECTIVES"
  "\n	The features required to write a software code in an efficient manner."
  "\n	Coding styles and guidelines that help in writing source codes with no minimum errors."
  "\n	Coding methodology which is used to analyze, design, and implement programs"
  "\n	Various programming practices that are used to write source codes"
  "\n	Various code verification techniques	that are used to detect	errors introduced while writing programs."

  "\nFEATURES OF SOFTWARE CODES"
  "\n	The code written for software should be according to the requirements of the users. A program is said to be good if the software code is flawless or contains minimum errors. For the effective performance of the software, some particulars features are required in almost all languages that are used to write the software code."

  "\nSIMPLICITY"
  "\n	Software code should be written in a simple and concise manner. Simplicity should be maintained in the organization, Implementation, and design of the software code."

  "\nMODULARITY"
  "\n	Breaking the software into several modules not only makes it easy to understand but also easy to debug. With the modularity feature, the same code segment can be reused in one or more software programs."

  "\nDESIGN"
  "\n	Software code is properly designed if it is presented in a proper manner. The design of  the software should be decided before beginning to write the software code. Writing the software code in a specific, consistent style helps other software developers in reviewing it."

  "\nEFFICIENCY"
  "\nA program is said to be efficient if it makes optimal use of the available resources."

  "\nCLARITY"
  "\n	Software codes should be clear so that developers are able to understand the program without any complexity. Clarity can be achieved by using features such as simplicity, readability, and modularity. Note that clarity comprises clarity of code, clarity of design, and clarity of purpose so that one knows what occurs at each level in the software program."

  "\nACCESSIBILITY"
  "\n	Software codes should be written in a way that the software components (ex: files) are easily available and accessible. For the files and functions to be accessible, they should have meaningful names as well as supporting captions and text for each image."

  "\nSTABILITY"
  "\n	Software codes are said to be stable if they are able to work correctly on different platforms without affecting their layout and consistency. To check for stability, software codes should be tested for errors and inconsistency."


  "\nCODING GUIDELINES AND METHODOLOGY"

  "\nCODING GUIDELINES"
  "\nWriting an efficient software code requires a thorough knowledge of programming. This knowledge can be implemented by following a coding style which comprises several guidelines that help in writing the software code efficiently and with minimum errors. These guidelines, known as coding guidelines, are used to implement individual programming language constructs, comments, formatting, and so on. These guidelines, if followed, help in preventing errors, controlling the complexity of the program, and increasing the readability and understandability of the program."

  "\nSince there are numerous programming languages for writing software codes, each having different features and capabilities, coding style guidelines differ one language to another. However. There are some basic guidelines which followed in all programming languages. These include naming conventions, commenting convention, and formatting convention."

  "\nThere are certain rules for naming variables, function and methods in the software code."
  "\nThese naming conventions help software developers in understanding the use of the particular variable or function. The guidelines use to assign a name to any variable, function, and method are listed below."

  "\nAll the variable, function, and methods should be assigned names that make the codes understandable to the reader. By using meaningful names, the code can be self-explanatory, thus minimizing the effort of writing comments for variables."

  "\n	For example, if two variables are required to refer to ‘sales tax’ and ‘income tax’, they should be assigned names such as ‘salesTax’ and ‘incomeTax’."

  "\nFor names, a full description in a commonly spoken language (for example English) should be used. In addition, the use of abbreviation should be avoided."

  "\n	For example, variable names ‘contactNumber’ and ‘address’ should be used instead of ‘cno’ and ‘add’."

  "\nShort and clear names should be assigned in place of long names."

  "\n	For example, ‘multiplyTheTwoNumbers’ can be shortened to ‘multiplyNumbers’ as it is clear and short enough to expressed in reasonable length."

  "\nThe names of function should be meaningful and should describe the purpose of the function with clarity and briefness. Like variables, names should be self-explanatory so that no additional description about the task of that function is required."

  "\n	The function name should begin with a verb. In case the verb itself is not descriptive, an additional noun or adjective can be used with the verb."

  ],
    [
  "\nCHAPTER 6: Creating Flow Graphs (TESTING)"
  "\nFlow Graphs"
  "\n	A flow graph represents the logical flow within a program . For this . It make of a notation . A flow graph uses different symbols"
  "\n	Namely, circles and arrows to represent various statements and flow of control within the program . Circles represent nodes which are used to depict the procedural statements present in the program . A sequence of process boxes and decision box used in a flowchart can be easily mapped into  a single node."
  "\n	Arrow represents edges or links which are use depict the  flow of control within the program. It is necessary for every edge to end in a node irrespective of whether represents a procedural statement."

  "\nFigure A"
  "\nSequence"

  "\nFigure B"
  "\nFlow chart and Flow Graph"

  "\nIn a flow graph. The area bounded by edges and nodes is known as region. In addition, area outsides the graph is also counted as a region while counting regions. A flow graph can be easily understood with the help of a diagram. Note that a node that contains a condition is known as predicted node, which contains one or more edges."

  "\nFinding independent paths"
  "\n	Finding independent paths – A path through the program which specifies  a new condition or minimum of one new set of processing statements is known as an independent paths. Note that a set of all independent paths within a program as its basis set."
  "\n	A test case is developed to ensure that while testing all statement the program get exercised at least once. For example all the independent paths. Listed below"
  "\n•	P1: 1-9"
  "\n•	P2 :1-2-7-8-1-5"
  "\n•	P3: 1-2-3-4-6-8-1-9"
  "\n•	P4:1-2-3-5-6-8-1-9"

  "\n	Where P1,P2,P3 and P4 represent different independent paths present in the program .To determine the number of independent paths through a programs the cyclomatic complexity metric is used that provides a quotative measure of the logical complexity of a program. The value of this metric defines the number of test cases that should be developed to ensure that all statements in the program get exercised at least once during testing. Cyclomatic complexity of a program can be computed using any of the following three methods"
  "\n1.	By counting the total numbers of regions in the flow graph of a program. For example in figure 6.25b there are for regions in the flow graph represented by R1,R2,R3, and R4 : hence the cyclomatic complexity is four."
  "\n2.	By using the following formula"
  "\nCC = E – N + 2"
  "\n•	Where"
  "\n•	CC  = The cyclomatic complexity of the program"
  "\n•	E      = The number of edges in the flow graph"
  "\n•	N     =  The number of nodes in the flow graph"
  "\nFor Example  in Figure B, E = 11, N =9 Therefore CC =11 – 9 +2=4"
  "\nBy using the formula"
  "\n•	CC = P + 1"


  "\nAppendices"
  "\n	Provides information about the test specification document . Appendices serve as a supplementary material that is provided at the end of the document"

  "\nSystem Testing"
  "\n	Software is integrated with other elements such as an hardware,"
  "\n	People and data base. This system is then checked for errors using testing. IEEE defines system testing as a “testing conducted on a complete integrated system to evaluate with its specified recruitment”"
  "\nWhere"
  "\n		P+ the number of predicate nodes in the flow graph"
  "\n	For example . In Figure 6.5{b} P = 3 Therefore, CC = 3 + 1 +4"
  "\n	Note: Cyclomatic complexity can be calculated either manually generate"
  "\n	For small program suites or using automated tools. However , for most operational environments ,automated tools are preferred"
  "\nDeriving Test Cases"

  "\n•	In this , basis path testing is presented  as a series of steps and cases are developed to ensure that all statements within the programs get  exercised at least once while performing basis paths in  the program derived"

  "\nThe basis set can be derived using the steps listed below"

  "\n1.	Draw the flow graphs of the program ."
  "\n•	A  flow graph is constructed using symbols previously discussed. For example a program to find the greater two numbers is given below."
  "\nProcedure greater:"
  "\nInteger x, y, z =0:"
  "\n1. enter the value of x:"
  "\n2 . enter the value of y:"
  "\n3. if x > y then z=x:"
  "\nelse"
  "\n4. z   =  y"
  "\n5.  end greater"
  ],
    [
  "\nChapter 7: Software Maintenance"

  "\nBASICS OF SOFTWARE MAINTENANCE"

  "\nSoftware does not wear out or get tired. However, it needs to be upgraded and enhanced to meet new user requirements. IEEE defines maintenance as a process of modifying a software system or component after delivery to correct faults, to improve performance or other attributes or adapt the product to a changed environment."

  "\nSoftware maintenance serves the following purposes."
  "\n	Providing continuity of service: The software maintenance process focuses on fixing errors, recovering from failures."
  "\n	Supporting mandatory upgrades: Software maintenance supports upgradations, if required, in a software system."
  "\n	Improving the software to support user requirements: Requirements may be requested to enhance the functionality of the software."
  "\n	Facilitating future maintenance work: Software maintenance also facilitates future maintenance work."

  "\nChanging a Software System"

  "\nAs stated earlier, the need for software maintenance arises due to changes required in the software system. The concept of software maintenance and evolution of systems was first introduced by Lehman, who carried out several studies and proposed five laws based on these studies."

  "\nThe five laws stated by Lehman are listed in Table 7.1"

  "\nLegacy System"

  "\nThe term ‘legacy system’ describes an old system, which remains in operation within an organization. These systems were developed according to the ‘dated development practice ‘. Legacy systems were not designed to accommodate changes. This is because of the following reasons."
  "\n	Short lifetime expectancy"
  "\n	Failure of process models to treat evolution as an important activity"
  "\n	Constraints present at the time of development"

  "\nThe Components of a Legacy System"
  "\nThe ’evolvability’ of a legacy system is determined by the parts that constitute the legacy system (see Figure 7.1)."

  "\nSoftware Maintenance Prediction"

  "\nSince unexpected maintenance coats may lead to an unexpected increase in costs, it is important to predict the effect of modifications in the software system."

  "\nFigure 7.2 shows various maintenance predictions."

  "\nAfter a system has been put into operation, several process metrics are used to predict the software maintainability."
  "\n	 Corrective maintenance"
  "\n	 Average time required for impact analysis"
  "\n	 Number of outstanding change requests"
  "\n	 Average time taken to implement a change request"

  "\nFactors Affecting Software Maintenance"

  "\nMany factors directly or indirectly lead to high maintenance costs. This framework comprises user requirements, organizational and operational environment, maintenance process, maintenance personnel, and the software product."

  "\nRelationship between Software Maintenance Framework Elements"

  "\n	 Relationship of software product and environment."
  "\n	 Relationship of the software product and user."
  "\n	 Relationship of software product and software maintenance team."

  "\nIf user requirements need major changes in the software, a lot of time may be consumed in implementing them. Similarly, users may opt for changes that are not according to the software standards or policies of a company. This situation creates a conflict between users and the software maintenance team. To implement user requirements in software, the following characteristics should be considered."

  "\nFeasible"
  "\nDesirable"
  "\nPrioritized"

  "\nThe working of software is affected by two kinds of environments, namely, organizational environment and operational environment."
  "\nIn both the environment, scheduling of the maintenance process can create problems."
  "\nThe facets of a maintenance process which affect the evolution of software or contribute to high maintenance costs are listed below."
  "\n	Errors detection and correction"
  "\n	Difficulty in capturing change (and changing) requirements"
  "\n	Software engineering paradigm shift."

  "\nSoftware Product"
  "\nThe aspects of software products that contribute to the maintenance cost are listed below."
  "\n	Difficulty of the application domain"
  "\n	 Inflexibility in programs"
  "\n	 Quality of the documentation"

  "\nSoftware Maintenance Team"
  "\nThe group of individuals responsible for the software maintenance is referred to as the software maintenance team, which may not comprise the development team that built the software."

  "\nVarious functions performed by the software maintenance team are listed below."
  "\n	 Locating information in system documentation"
  "\n	 Keeping system documentation up to date"
  "\n	 Improving system functionalities to adapt new environment"
  "\n	 Enhancing system to perform new functions according to the user’s needs"
  "\n	 Detecting root cause of failures, if any"
  "\n	Handling changes made to the system"

  "\nThe aspects of a maintenance team that lead to high maintenance costs are listed below."
  "\n	 Staff turnover"
  "\n	 Domain expertise"

  ],
    [
  "\nChapter 8 Software Metrics"
  "\nSOFTWARE MEASUREMENTS"
  "\nTo assess the quality of the engineered product or system and to better understand the models that are created, some measures are used. These measures are collected throughout the software development life cycle with an intention to improve the software process on a continuous basis. Measurement helps in estimation, quality control, productivity assessment and project control throughout a software project. Also, measurement is used by software engineers to gain insight into the design and development of the work products. In addition, measurement assists in strategic decision-making as a project proceeds."
  "\nSoftware measurements are of two categories, namely, direct measures and indirect measures. Direct measures include software processes like cost and effort applied and products like lines of code produced, execution speed, and other defects that have been reported. Indirect measures include products like functionality, quality, complexity, reliability, maintainability, and many more."
  "\nGenerally, software measurement is considered as a management tool which if conducted in an effective manner, helps the project manager and the entire software teanı to take decisions that lead to successful completion of the project. Measurement process is characterized by a set of five activities, which are listed below."
  "\n• Formulation: This performs measurement and develops appropriate metric for software under consideration."
  "\n• Collection: This collects data to derive the formulated metrics."
  "\n• Analysis: This calculates metrics and the use of mathematical tools."
  "\n• Interpretation: This analyzes the metrics to attain insight into the quality of representation."
  "\n• Feedback: This communicates recommendation derived from product metrics to the software team."
  "\nNote that collection and analysis activities drive the measurement process. In order to perform these activities effectively, it is recommended to automate data collection and analysis, establish guidelines and recommendations for each metric, and use statistical techniques to interrelate external quality features and internal product attributes."

  "\nMeasured Data"
  "\nBefore data is collected and used, it is necessary to know the type of data involved in the software metrics. lists different types of data, which are identified in metrics along with their description and the possible operations that can be performed on them."
  "\n• Nominal data: Data in the program can be measured by placing it under a category. This category of program can be a database program, application program, or an operating system program. For such data, operation of arithmetic type and ranking of values in any order (increasing or decreasing) is not possible. The only operation that can be performed is to determine whether program 'X' is the same as program 'Y'."
  "\n• Ordinal data: Data can be ranked according to the data values. For example, experience in application domain can be rated as very low, low, medium, or high. Thus, experience can easily be ranked according to its rating."
  "\n• Interval data: Data values can be ranked and substantial differences between them can also be shown. For example, a program with complexity level 8 is said to be 4 units more complex than a program with complexity level 4."
  "\n• Ratio data: Data values are associated with a ratio scale, which possesses an absolute zero and allows meaningful ratios to be calculated. "
  "\nFor example,program gram lines expressed in lines of code. It is desirable to know the measurement scale for metrics. For example, if metrics values are used to represent a model for a software process, then metrics associated with the ratio scale may be preferred."

  "\nCLASSIFICATION OF SOFTWARE METRICS"
  "\nAs discussed earlier, measurement is done by metrics. Three parameters are measured. process measurement through process metrics, product measurement through product metrics, and project measurement through project metrics."
  "\nProcess metrics assess the effectiveness and quality of software process, determine maturity of the process effort required in the process, effectiveness of defect removal during development, and so on. Product metrics is the measurement of work product produced during different phases of software development. Project metrics illustrate the project characteristics and their execution."

  "\nPROCESS METRICS"
  "\nTo improve any process, it is necessary to measure its specified attributes, develop a set of meaningful metrics based on these attributes, and then use these metrics to obtain indicators in order to derive a strategy for process improvement."
  "\nUsing software process metrics, software engineers are able to assess the efficiency of the software process that is performed using the process as a framework. In Figure 8.1, process is placed at the center of the triangle connecting three factors (product, people, and technology), which have an important influence on software quality and organization performance. The skill and motivation of the people, the complexity of the product and the level of technology used in the software development have an important influence on the quality and team performance. Also, in Figure 8.1, the process triangle exists within the circle of environmental conditions, which includes development environment, business conditions, and customer/user characteristics."
  ]
  ];
  List<List> content2 = [
    [
  "\nChapter 9 Software Planning and Scheduling."
  "\nRESPONSIBILITIES OF SOFTWARE PROJECT MANAGER"
  "\nProper project management is essential for the successful completion of a software project and the person who is responsible for it is called project manager. To do his job effectively, the project manager must have certain set of skills. This section. discusses both the job responsibilities of project manager and the skills required by him."
  "\n• Involves with the senior managers in the process of appointing team members"
  "\nBuilds the project team and assigns tasks to various team members"
  "\n• Responsible for effective project planning and scheduling, project monitoring and control activities in order to achieve the project objectives"
  "\n• Acts as a communicator between the senior management and the other persons"
  "\ninvolved in the project like the development team and internal and external stakeholders"
  "\n• Effectively resolves issues (if any) that arise between the team members by changing their roles and responsibilities"
  "\n• Modifies the project plan (if required) to deal with the situation."
  "\nAlthough the actual skills for effective project management develop with experience, every project manager must exhibit some basic skills that are listed below"

  "\n• Must have the knowledge of different project management techniques like risk management, configuration management, cost estimation techniques, etc."
  "\n• Must have the ability to make judgement, since project management frequently requires making decisions."
  "\n• Must have good grasping power to learn the latest technologies to adapt to project requirements."
  "\n• Should be open-minded enough to accept new ideas from the project members. In addition, he should be creative enough to come up with new ideas"

  "\nPROJECT PLANNING"
  "\nBefore starting a software project, it is essential to determine the tasks to be performed and properly manage allocation of tasks among individuals involved in the software development. Hence, planning is important as it results in effective software development."
  "\nProject planning is an organized and integrated management process, which focuses on activities required for successful completion of the project. It prevents obstacles that arise in the project such as changes in projects or organization's objectives, non-availability of resources, and so on. Project planning also helps in better utilization of resources and optimal usage of the allotted time for a project. The other objectives of project planning are listed below."
  "\nIt defines the roles and responsibilities of the project management team members."
  "\n• It ensures that the project management team works according to the business objectives"
  "\nIt checks feasibility of the schedule and user requirements."
  "\n• It determines project constraints."
  "\nSeveral individuals help in planning the project. These include senior management and project management team. Senior management is responsible for employing team members and providing resources required for the project. The project management team, which generally includes project managers and developers, is responsible for planning, determining, and tracking the activities of the project. Table 9.1 lists the tasks performed by individuals involved in the software project."
  "\nProject planning should be effective so that the project begins with well-defined tasks. Effective project planning helps to minimize the additional costs incurred on the project while it is in progress. For effective project planning, some principles are followed. These principles are listed below."
  "\n• Planning is necessary: Planning should be done before a project begins. For effective planning, objectives and schedules should be clear and understandable."
  "\n• Risk analysis: Before starting the project, senior management and the project management team should consider the risks that may affect the project. For example, the user may desire changes in requirements while the project is in progress. In such a case, the estimation of time and cost should be done according to those requirements (new requirements)."
  "\n• Tracking of project plan: Once the project plan is prepared it should be tracked and modified accordingly."
  "\n• Meet quality standards and produce quality deliverables: The project plan should identify processes by which the project management team can ensure quality in software. Based on the process selected for ensuring quality, the time and cost for the project is estimated."
  "\n• Description of flexibility to accommodate changes: The result of project planning is recorded in the form of a project plan, which should allow new changes to be accommodated when the project is in progress."
  "\nProject planning comprises project purpose, project scope, project planning process, and project plan. This information is essential for effective project planning and to assist project management team in accomplishing user requirements."
  "\nProject Purpose"
  "\nSoftware project is carried out to accomplish a specific purpose, which is classified into two categories, namely, project objectives and business objectives. The commonly followed project objectives are listed below."
  "\n• Meet user requirements: Develop the project according to the user requirements after understanding them."
  "\n• Meet schedule deadlines: Complete the project milestones as described in the project plan on time in order to complete the project according to the schedule."
  "\n• Be within budget: Manage the overall project cost so that the project is within the allocated budget."
  "\n• Produce quality deliverables: Ensure that quality is considered for accuracy and overall performance of the project."
  "\nProject Scope"
  "\nWith the help of user requirements, the project management team determines the scope of the project before the project begins. This scope provides a detailed description of functions, features, constraints, and interfaces of the software that are to be considered. Functions describe the tasks that the software is expected to perform. Features describe the attributes required in the software as per the user requirements. Constraints describe the limitations imposed on software by hardware, memory, and so on. Interfaces describe the interaction of software components (like modules and functions) with each other. Project scope also considers software performance, which in turn depends on its processing capability and response time required to produce the output."
  "\nOnce the project scope is determined, it is important to properly understand it in order to develop software according to the user requirements. After this, project cost and duration are estimated. If the project scope is not determined on time, the project may not be completed within the specified schedule. Project scope describes the following information."
  ],
    [
  "\nSoftware Cost Estimation"

  "\nSoftware Product Cost Factors"
  "\n•	Experience in application domain: in a software project, the developer works in an application domain, which composes software and hardware technologies that are used to develop the project."
  "\n•	Product Complexity: Generally, software is categorized into three parts namely application programs, utility programs, and system programs. (Application Programs like MS word, MS Excel, and so on.) can be defined as a program that performs specific functions directly for the end user. Utility Programs (like compiler, linker, and loader) programs that perform functions such as file copying, sorting, merging, memory dump analysis. System Program can be defined as a program that implements high-level functionality of an operating system. There are three levels of product complexity, namely, organic, semi-detached, and embedded, which correspond to the application programs, utility program, and system program respectively."
  "\nProject Size: is an important criterion for estimating the cost of a software project. A large-sized project consumes more resources than a smaller project. Effort increases, the cost of software also increases."
  "\nAvailable Time: Time available to develop a software project according to the user requirements is considered an important factor in determining the project cost."
  "\nProgrammer Ability: Software project is also dependent on the ability of the programmers who are involved in the software development."
  "\nLevel of Technology: In a software development project, the level of technology also helps in determining the cost of a project."
  "\nRequired Level of Reliability: Is generally expressed in terms of accuracy, robustness, consistency, and completeness of the source code."
  "\nEffort Multiplier for Software Reliability"
  "\nCategory	Effect of failure	Effect multiplier"
  "\nVery low	Slight inconvenience	0.75"
  "\nLow	Loses Easily Recovered	0.88"
  "\nNominal	Moderately difficult to recovered losses	1.00"
  "\nHigh	High Financial Cost"
  "\n1.15"
  "\nVery high	Risk to Human Life	1.40"

  "\nSoftware Cost Estimation Process"
  "\n•	The lower the cost of conducting business identify and monitor cost and schedule risk factors, and increase the skill of key staff members, a software estimation process is followed."
  "\nProblem Based Estimation"
  "\n•	Lines of code and function point are described as a measure from which productivity metrics can be calculated. During software project estimation, LOC and FP are used in two different ways."
  "\n•	As an estimation variable to size each element of the software"
  "\n•	As baseline metrics gathered from the previous projects and used with estimation variables to develop cost and effort projections."
  "\n•	In software project development, a process is followed to accomplish the objectives of a project. A commonly used technique for estimating the effort in a software project is to base the estimate on the process which will be used. For this, the process is decomposed into smaller set of tasks such as analysis, design, coding, and so on."
  "\nACTIVITY TASK	CUSTOMER COMMUNICATION"
  "\nPLANNING"
  "\nRISK ANALYSIS"
  "\nENGINEERING"
  "\nANALYSIS DESIGN"

  "\nCONSTRCTION RELEASE"
  "\nCODE            TEST	TOTAL"
  "\nFunction 1				0.40	1.50	0.40	4.00	6.30"
  "\nFunction 2				0.65	2.00	0.60	1.00	4.25"
  "\nFunction 3				0.40	3.00	1.00	2.00	6.40"
  "\nFunction 4				0.40	2.00	1.00	2.00	5.90"
  "\nFunction 5				0.40	2.00	0.75	2.50	5.65"
  "\nFunction 6				0.15	1.00	0.50	2.50	4.15"
  "\nFunction 7				0.40	1.00	0.50	1.00	2.90"
  "\nTotal	0.25	0.25	0.25	02.80	12.50	4.75	15.50	36.00"

  "\nConstructive Cost Model"
  "\n•	The constructive cost model is based on the hierarchy of three models, namely, basic model, intermediate model, and advance model."
  "\n•	In the basic model, only the size of project is considered while calculating effort. To calculate effort, use the following equation (known as Effort Equation)."
  "\n•	E = A x (size) B"
  "\n•	Where E is the effort in person-months and the size is measured in terms of KDLOC. The values of constants ‘A’ and ‘B’ depend on the type of the software project. In this model, the values of constants (‘A’ and ‘B’) for three different types of projects are listed."
  "\nValues of Constants for different projects"
  "\nProject type	A	F"
  "\nOrganic	2.4	1.05"
  "\nSemi-detached	3.0	1.12"
  "\nEmbedded	3.6	1.20"
  "\nConstructive Cost Model II"
  "\n•	The COCOMO model is one of the most widely used methods for cost estimation."
  "\n•	However, this model assumes that the software is developed according to the waterfall development model using standard programming languages like C and FORTRAN."

  "\n•	Compute object points:  the object points are computed using the counts of number of object instances, that is, screens, reports, or 3GL components, which are required to develop the application. Screens are classified based on number of views and source whereas reports are based on sections and source."
  "\n•	Classification of object instances: Each object instance is classified into simple, medium, and difficult complexity levels depending on the criteria suggested by Boehm and shown in table."

  "\nClassification of Object Points into Complexity Levels"
  "\nNumber of views	Number of sections contained	# and sources or data tables"
  "\nTotal <3/<2 server <3 client	Total <8 (2-3 server 3-5 client)	Total(>3 server, >5 client)"
  "\n<3	0 or 1	Simple	Simple	Medium"
  "\n3-7	2 or 3	Simple	Medium	Difficult"
  "\n>8	4+	Medium	Difficult	Difficult"
  "\n•	Assigning complexity weight to each object instance: The object instances are rated against numeric value (weights). These numeric values show the effort required to implement an instance of the complexity level."

  ],
    [
  "\nSoftware Quality"

  "\nWhat is Software Quality?"
  "\n•	Simplistically, quality is an attribute of software that implies the software meets its specification."
  "\n•	This definition is too simple for ensuring quality in software systems."
  "\n–	Software specifications are often incomplete or ambiguous."
  "\n–	Some quality attributes are difficult to specify."
  "\n–	Tension exists between some quality attributes, e.g. efficiency vs. reliability."
  "\nSoftware Quality Attributes"
  "\n•	Safety"
  "\n•	Security"
  "\n•	Reliability"
  "\n•	Resilience"
  "\n•	Robustness"
  "\n•	Understandability"
  "\n•	Testability"
  "\n•	Adaptability"
  "\n•	Modularity"
  "\n•	Complexity"
  "\n•	Portability"
  "\n•	Usability"
  "\n•	Reusability"
  "\n•	Efficiency"
  "\n•	Learnability"
  "\nSoftware Quality"
  "\n•	Conformance to explicitly stated functional and performance requirements, explicitly documented development standards, and implicit characteristics that are expected of all professionally developed software."
  "\n–	Software requirements are the foundation from which quality is measured."
  "\n•	Lack of conformance to requirements is lack of quality."
  "\n–	Specified standards define a set of development criteria that guide the way software is engineered."
  "\n•	If the criteria are not met, lack of quality will almost surely result."
  "\n–	There is a set of implicit requirements that often goes unmentioned."
  "\n•	If software conforms to its explicit requirements but fails to meet its implicit requirements, software quality is suspect."
  "\nSoftware Quality Assurance"
  "\n•	To ensure quality in a software product, an organization must have a three-prong approach to quality management:"
  "\n–	Organization-wide policies, procedures and standards must be established."
  "\n–	Project-specific policies, procedures and standards must be tailored from the organization-wide templates."
  "\n–	Quality must be controlled; that is, the organization must ensure that the appropriate procedures are followed for each project."
  "\n•	Standards exist to help an organization draft an appropriate software quality assurance plan."
  "\n–	ISO 9000-3"
  "\n–	ANSI/IEEE standards"
  "\n•	External entities can be contracted to verify that an organization is standard-compliant."

  "\nA Software Quality Plan"

  "\nSQA Activities"
  "\n•	Applying technical methods"
  "\n–	To help the analyst achieve a high-quality specification and a high-quality design."
  "\n•	Conducting formal technical reviews"
  "\n–	A stylized meeting conducted by technical staff with the sole purpose of uncovering quality problems."
  "\n•	Testing Software"
  "\n–	A series of test case design methods that help ensure effective error detection."
  "\n•	Enforcing standards"
  "\n•	Controlling change"
  "\n–	Applied during software development and maintenance."
  "\n•	Measurement"
  "\n–	Track software quality and assess the ability of methodological and procedural changes to improve software quality."
  "\n•	Record keeping and reporting."
  "\n–	Provide procedures for the collection and dissemination of SQA information."
  "\nAdvantages of SQA"
  "\n•	Software will have fewer latent defects, resulting in reduced effort and time spent during testing and maintenance."
  "\n•	Higher reliability will result in greater customer satisfaction."
  "\n•	Maintenance costs can be reduced."
  "\n•	Overall, the life cycle cost of software is reduced."
  "\nDisadvantages of SQA"
  "\n•	It is difficult to institute in small organizations, where available resources to perform necessary activities are not available."
  "\n•	It represents cultural change - and change is never easy."
  "\n•	It requires the expenditure of dollars that would not otherwise be explicitly budgeted to software engineering or QA."
  "\nQuality Reviews"
  "\n•	The fundamental method of validating the quality of a product or a process."
  "\n•	Applied during and/or at the end of each life cycle phase."
  "\n–	Point out needed improvements in the product of a single person or team."
  "\n–	Confirm those parts of a product in which improvement is either not desired or not needed."
  "\n–	Achieve technical work of more uniform, or at least more predictable, quality than what can be achieved without reviews, to make technical work more manageable."
  "\n•	Quality reviews can have different intents:"
  "\n–	review for defect removal"
  "\n–	review for progress assessment"
  "\n–	review for consistency and conformance"
  ],
  ];
  List<List> getContent() {
    return [content, content2];
  }

  List<List> getLessons() {
    return [lesson1, lesson2];
  }
}